@@@ This code works on my Pi3.@@@ It uses GPIO 22,23,and 24 for input on pushbuttons, and@@@ PWM1 (which is known as PWM0 on the Pi header) for output.@@@ It routes the PWM output through GPIO12.	.equ	SHORT_DELAY,	50	@@  These are the offsets for the GPIO registers that we will use	.equ	GPFSEL0,   0x0000	.equ	GPFSEL1,   0x0004	.equ	GPFSEL2,   0x0008	.equ	GPFSEL3,   0x000C	.equ	GPFSEL4,   0x0010	.equ	GPFSEL5,   0x0014	.equ	GPSET0,    0x001C	.equ	GPSET1,    0x0020	.equ	GPCLR0,    0x0028	.equ	GPCLR1,    0x002c	.equ	GPLEV0,    0x0034	.equ	GPPUD,     0x0094	.equ	GPPUDCLK0, 0x0098 	.equ	GPPUDCLK1, 0x009C	.equ PWM_CTL,  0x0	.equ PWM_STA,  0x4	.equ PWM_DMAC, 0x8	.equ PWM_RNG1, 0x10	.equ PWM_DAT1, 0x14	.equ PWM_FIF1, 0x18	.equ PWM_RNG2, 0x20	.equ PWM_DAT2, 0x24	.equ	PWM_CTL_CLRF,  0x0040	.equ	PWM_CTL_PWEN1, 0x0001	.equ	PWM_CTL_MODE1, 0x0002	.equ	PWM_CTL_RPTL1, 0x0004	.equ	PWM_CTL_SBIT1, 0x0008	.equ	PWM_CTL_POLA1, 0x0010	.equ	PWM_CTL_USEF1, 0x0020	.equ	PWM_CTL_MSEN1, 0x0080	.equ	PWM_CTL_PWEN2, 0x0100	.equ	PWM_CTL_MODE2, 0x0200	.equ	PWM_CTL_RPTL2, 0x0400	.equ	PWM_CTL_SBIT2, 0x0800	.equ	PWM_CTL_POLA2, 0x1000	.equ	PWM_CTL_USEF2, 0x2000	.equ	PWM_CTL_MSEN2, 0x8000	.equ	PWMCLK_CNTL,	0xA0	.equ	PWMCLK_DIV,	0xA4	.datapofmt:	.asciz	"register offset is %08X and shift is %d\n"cntfmt:	.asciz	"count is now %d\n"pwrtab:	.byte	0xFE,0xD0,0xB0,0x90,0x70,0x50,0x30,0x10,0x00	.text@@@ enable/disable the internal pullup/pulldown resistors@@@ set_pud(gpio_pin_num, direction)@@@ direction: 0=float, 1=pull down, 2=pull upset_pud:stmfd	sp!,{r0-r3}	@@ Load the Base Address of the GPIO device	ldr	r3,=gpiobase	@ load pointer to the address of the gpio device	ldr	r3,[r3]		@ load address of the gpio device	@@ Enable the internal pull-up resistors on button pins 	@@ Store direction in GPPUD 	str	r1,[r3,#GPPUD] w1:	mov	r2,#SHORT_DELAY 	subs	r2,r2,#1 	bcc	w1 	@@ Write to GPPUDCLK0 to clock the signals into GPIO 22,23,24 	mov	r2,#1	lsl	r2,r2,r0 	str	r2,[r3,#GPPUDCLK0] w2:	mov	r2,#SHORT_DELAY 	subs	r2,r2,#1 	bcc	w2	@@ Write to GPPUD to remove the control signal 	mov	r2,#0 	str	r2,[r3,#GPPUD] 	@@ Write to GPPUDCLK0/1 to remove the clock 	@@ Write to GPPUDCLK0 to clock the signals into GPIO 22,23,24 	mov	r2,#0 	str	r2,[r3,#GPPUDCLK0]	ldmfd	sp!,{r0-r3}	mov	pc,lr@@@ pin_offest finds the offset to the correct GPFSEL register@@@ it returns the offset in r3, and the shift amount in r0pin_offset:	subs	r0,r0,#10	@ pins 0-9 are in GPFSEL0	movlt	r3,#GPFSEL0	blt	have_offset	subs	r0,r0,#10	@ pins 10-19 are in GPFSEL1	movlt	r3,#GPFSEL1	blt	have_offset	subs	r0,r0,#10	@ pins 20-29 are in GPFSEL2	movlt	r3,#GPFSEL2	blt	have_offset	subs	r0,r0,#10	@ pins 30-39 are in GPFSEL2	movlt	r3,#GPFSEL3	blt	have_offset	subs	r0,r0,#10	@ pins 40-49 are in GPFSEL2	movlt	r3,#GPFSEL4	blt	have_offset	sub	r0,r0,#10	@ pins 40-49 are in GPFSEL2	mov	r3,#GPFSEL5have_offset:	add	r0,r0,#10	@ make 0<=r0<=9	add	r0,r0,r0,asl #1 @ r0 *= 3	stmfd	sp!,{r0-r3,lr}	mov	r2,r0	mov	r1,r3	ldr	r0,=pofmt	bl	printf	ldmfd	sp!,{r0-r3,lr}	mov	pc,lr@@@ gpio_dir_input sets the pin specified in r0 to be an input pingpio_dir_input:	stmfd	sp!,{lr}	@@ Load the Base Address of the GPIO device	ldr	r1,=gpiobase	@ load pointer to the address of the gpio device	ldr	r1,[r1]		@ load address of the gpio device	bl	pin_offset 	@ get the offset in r3 and shift in r0	add	r1,r1,r3	@ get pointer to the FPFSEL register	ldr	r3,[r1]		@ read the FPFSEL register	mov	r2,#7		@ create bit mask for 3 bits we need to clear	lsl	r2,r2,r0	mvn	r2,r2	and	r2,r2,r3	@ clear the 3 bits	str	r2,[r1]		@ write the FPFSEL register	str	r2,[r1]		@ write the FPFSEL register	ldmfd	sp!,{pc}@@@ gpio_dir_output sets the pin specified in r0 to be an output pingpio_dir_output:	stmfd	sp!,{lr}	@@ Load the Base Address of the GPIO device	ldr	r1,=gpiobase	@ load pointer to the address of the gpio device	ldr	r1,[r1]		@ load address of the gpio device	bl	pin_offset 	@ get the offset in r3 and shift in r0	add	r1,r1,r3	@ get pointer to the FPFSEL register	ldr	r3,[r1]		@ read the FPFSEL register	mov	r2,#7		@ create bit mask for 3 bits we need to clear	lsl	r2,r2,r0	mvn	r2,r2	and	r3,r2,r3	@ clear the 3 bits	mov	r2,#1		@ create bit mask for the bit we need to set	lsl	r2,r2,r0	orr	r2,r2,r3	@ set the 3 bits	str	r2,[r1]		@ write the FPFSEL register	ldmfd	sp!,{pc}@@@ gpio_alt_func sets the pin specified in r0 to the function specified in r1gpio_alt_func:	stmfd	sp!,{r4,lr}	mov	r4,r1	@@ Load the Base Address of the GPIO device	ldr	r1,=gpiobase	@ load pointer to the address of the gpio device	ldr	r1,[r1]		@ load address of the gpio device	bl	pin_offset 	@ get the offset in r3 and shift in r0	add	r1,r1,r3	@ get pointer to the FPFSEL register	ldr	r3,[r1]		@ read the FPFSEL register	mov	r2,#7		@ create bit mask for 3 bits we need to clear	lsl	r2,r2,r0	mvn	r2,r2	and	r3,r2,r3	@ clear the 3 bits	mov	r2,r4		@ create bit mask	lsl	r2,r2,r0	orr	r2,r2,r3	@ set the 3 bits	str	r2,[r1]		@ write the FPFSEL register	ldmfd	sp!,{r4,pc}buttonpress:	stmfd	sp!,{lr}waitpress:	@@ Read GPIO Level Register 0 (GPLEV0)	ldr	r1,[r0,#GPLEV0]	and	r1,r1,#((1<<22)|(1<<23)|(1<<24))	cmp	r1,#((1<<22)|(1<<23)|(1<<24))	beq	waitpress	@@ Button has been pressed - do debounce count	mov	r2,#(1<<20)debounce:	adds	r2,r2,#-1	bne	debounce	ldr	r1,[r0,#GPLEV0]	and	r1,r1,#((1<<22)|(1<<23)|(1<<24))	cmp	r1,#((1<<22)|(1<<23)|(1<<24))	beq	waitpress	mov	r0,r1	ldmfd	sp!,{pc}	.global	mainmain:	stmfd	sp!,{r4,r5,lr}	@@ map the devices into our address space	bl	IO_init	@@ Load the Base Address of the GPIO device	ldr	r4,=gpiobase	@ load pointer to the address of the gpio device	ldr	r4,[r4]		@ load address of the gpio device	@@ Set the direction bits for the pins	mov	r0,#22	bl	gpio_dir_input	mov	r0,#23	bl	gpio_dir_input	mov	r0,#24	bl	gpio_dir_input	@@ Configure pull-up resistors for input pins	mov	r0,#22	mov	r1,#2	bl	set_pud	mov	r0,#23	mov	r1,#2	bl	set_pud	mov	r0,#24	mov	r1,#2	bl	set_pud	@@ set count to 0 for button presses	mov	r5, #0	@@ set up GPIO 12 for alternate function 0 using gpio_alt_func    mov r0, #12
    mov r1, #4	bl	gpio_alt_func	@ Set up PWM clock	@@ disable pwm using pwmbase    ldr r0, =pwmbase
    ldr r1,[r0]
    mov r2, #0
    str r2, [r1, #PWM_CTL]
 	@@ Derive PWM clock direct from X-tal thus any system 	@@ auto-slow-down-clock-to-save-power does not effect it 	@@ The values below depends on the X-tal frequency!	@@ disable pwm clock using clkbase    ldr r2, =clkbase
    ldr r3,[r2]
    bic r4,r3, #0xffffffef
    cmp r4, #0
    addeq r4, r4, #0x10
    str r4, [r3] 	@@ wait for busy flag to clearbusywait:	@@ configure and start the clock
     ldr r0, =PWMCLK_CNTL     ldr r1, =clkbase
     ldr r2, [r1, r0]
     bic r2, #0xffffffbf
     lsr r2, #6
     cmp r2, #0
     bne busywait
 	@@ wait for busy flag to clear


    @@starting clock now?
        ldr r1, =clkbase
     ldr r2, [r1]
     ldr r3, =0x5a0c0000          @the password?
     str r3, [r2, #PWMCLK_DIV]
     ldr r1, =clkbase
     ldr r2, [r1]
     ldr r3, =0x5a000011
     str r3, [r2, #PWMCLK_CNTL]
 busywait2:     ldr r0, =PWMCLK_CNTL     ldr r1, =clkbase
     ldr r2, [r1, r0]
     bic r2, #0xffffffbf
     lsr r2, #6
     cmp r2, #0
     bne busywait2
	@@ configure pwm0 using pwmbase	@ set the pwm to 0% duty cycle (LED fully on)    ldr r1, =pwmbase
    mov r2, #0
    str r2, [r1,#PWM_DAT1]
	@ set the range for 0-0x70    ldr r1, =pwmbase
    mov r2, #0x70
    str r2,[r1,#PWM_RNG1]	@ set the pwm to 100% duty cycle (LED fully off)    ldr r1, =pwmbase
    mov r2, #0x70
    str r2, [r1,#PWM_DAT1]	@ enable the PWM	mov	r0,#(PWM_CTL_PWEN1|PWM_CTL_SBIT1)	str	r0,[r2,#PWM_CTL]	@@assuming r2 holds dereferenced address of pwmbaseloop:	@@ Read GPIO Level Register 0 (GPLEV0) when a button is pressed	mov	r0,r4	bl	buttonpress	moveq	r2,#0		@ Clear update flag	@@ check bits 22,23,24	mov	r1,#0	@@ Check input on GPIO 22	tst	r0,#(1<<22)	moveq	r2,#1		@ Set update flag	addeq	r5,r5,#1	@ Increment count	cmp	r5,#7	movgt	r5,#7	@@ Check input on GPIO 23	tst	r0,#(1<<23)	moveq	r2,#1		@ Set update flag	moveq	r5,#0       	@ Reset count	@@ Check input on GPIO 24	tst	r0,#(1<<24)	moveq	r2,#1		@ Set update flag	subeq	r5,r5,#1	@ Decrement count	cmp	r5,#0	movlt	r5,#0	@@ Skip printing and updating PWM if count did not change	cmp	r2,#1	bne	endloop	@@ Print current count	ldr	r0,=cntfmt	mov	r1,r5	bl	printf	@@ Update PWM duty cycle	rsb	r0,r5,#7	lsl	r0,r0,#4	ldr	r2,=pwmbase	ldr	r2,[r2]	str	r0,[r2,#PWM_DAT1]waitrelease:	ldr	r0,[r4,#GPLEV0]	and	r0,r0,#((1<<22)|(1<<23)|(1<<24))	cmp	r0,#((1<<22)|(1<<23)|(1<<24))	bne	waitrelease	@@ Button has been released - do debounce count	mov	r2,#(1<<20)debounc2:	adds	r2,r2,#-1	bpl	debounc2	ldr	r0,[r4,#GPLEV0]	and	r0,r0,#((1<<22)|(1<<23)|(1<<24))	cmp	r0,#((1<<22)|(1<<23)|(1<<24))	bne	waitreleaseendloop:	b	loop	ldmfd	sp!,{r4,r5,pc}